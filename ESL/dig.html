<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dig for Water ‚Äî Hidden Fountains (Keyboard)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --ground:#1f7a1f;
      --bubble:#fff;
      --text:#111;
      --accent:#ffd24d;
      --water:#1e90ff;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--ground);}
    #game{position:fixed;inset:0;background:var(--ground);overflow:hidden;display:block;}
    canvas{display:block;width:100vw;height:100vh;}
    .bubble{
      position:absolute;pointer-events:none;background:var(--bubble);color:var(--text);padding:6px 10px;border-radius:16px;box-shadow:0 6px 20px rgba(0,0,0,0.16);white-space:nowrap;font-weight:800;transform-origin:center center;transition:transform 180ms cubic-bezier(.2,.9,.2,1),opacity 180ms ease;display:inline-block;will-change:transform,opacity;
    }
    .bubble::after{content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:-8px;border:8px solid transparent;border-top-color:var(--bubble);}
    #ui{position:fixed;right:16px;top:16px;display:flex;flex-direction:column;gap:8px;z-index:40}
  </style>
</head>
<body>
  <div id="game" aria-label="Dig for Water game area">
    <canvas id="canvas"></canvas>
  </div>

  <div id="ui"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gameRect = document.getElementById('game');

    let W = 0, H = 0;
    const player = { x: 0, y: 0, r: 20, vx: 0, vy: 0, targetX: null, targetY: null, moving: false, startX:0, startY:0, moveStart:0, moveDuration:0 };
    const playerEmoji = 'üßë‚Äçüåæ';
    const waterEmoji = 'üíß';
    const baseStep = 56;
    const moveDuration = 240;
    const fountainCount = 3;
    const fountains = [];
    const bubbleLifetime = 1400;
    const detectNear = 160;
    const detectOnTop = 64;
    let bubbleTimer = null;

    const commandQueue = [];
    let processingQueue = false;
    const stepDelay = 140;

    function setCanvasSize(){
      W = Math.max(400, Math.floor(window.innerWidth));
      H = Math.max(300, Math.floor(window.innerHeight));
      canvas.width = W;
      canvas.height = H;
      player.x = Math.min(Math.max(player.x || W/2, 24), W-24);
      player.y = Math.min(Math.max(player.y || H/2, 24), H-24);
      draw();
    }

    function distance(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }

    function placeFountains(){
      fountains.length = 0;
      for(let i=0;i<fountainCount;i++){
        let fx, fy, safe=false;
        while(!safe){
          fx = 80 + Math.random()*(W-160);
          fy = 100 + Math.random()*(H-260);
          safe = true;
          for(const f of fountains) if(distance(fx,fy,f.x,f.y) < 160) safe = false;
        }
        fountains.push({x:fx,y:fy,visible:false, radius: 48});
      }
    }

    function resetGame(){
      player.x = W/2; player.y = H/2;
      player.vx = 0; player.vy = 0;
      player.targetX = null; player.targetY = null; player.moving = false;
      placeFountains();
      clearBubbles();
      commandQueue.length = 0;
      processingQueue = false;
      draw();
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground') || '#1f7a1f';
      ctx.fillRect(0,0,W,H);
      for(const f of fountains){
        if(f.visible) drawFountain(f.x,f.y,true);
      }
      drawPlayer();
    }

    function drawPlayer(){
      const size = Math.round(player.r * 2.6);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${size}px system-ui, -apple-system, "Segoe UI Emoji", "Noto Color Emoji", "Apple Color Emoji", sans-serif`;
      ctx.fillText(playerEmoji, player.x, player.y + 4);
      ctx.restore();
    }

    function drawFountain(x,y,active){
      if(!active) return;
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const size = 48;
      ctx.font = `${size}px system-ui, -apple-system, "Segoe UI Emoji", "Noto Color Emoji", "Apple Color Emoji", sans-serif`;
      ctx.fillText(waterEmoji, x, y - 10);
      ctx.restore();
    }

    function clearBubbles(){
      const existing = gameRect.querySelectorAll('.bubble');
      existing.forEach(e=>e.remove());
      if(bubbleTimer){ clearTimeout(bubbleTimer); bubbleTimer=null; }
    }

    function showBubble(text, x=player.x, y=player.y-56, sizeScale=1){
      clearBubbles();
      const d = document.createElement('div');
      d.className = 'bubble';
      d.textContent = text;
      gameRect.appendChild(d);
      const baseFont = 14;
      const fontSize = Math.round(baseFont * Math.min(Math.max(sizeScale, 0.6), 3));
      const horizPad = Math.round(10 * Math.min(Math.max(sizeScale, 0.6), 3));
      const vertPad = Math.round(6 * Math.min(Math.max(sizeScale, 0.6), 3));
      d.style.fontSize = fontSize + 'px';
      d.style.padding = vertPad + 'px ' + horizPad + 'px';
      const pad = 12;
      const rect = canvas.getBoundingClientRect();
      const px = x * (rect.width / W);
      const py = y * (rect.height / H);
      d.style.left = Math.min(Math.max(px - d.offsetWidth/2, pad), rect.width - d.offsetWidth - pad) + 'px';
      d.style.top = Math.min(Math.max(py - 60, pad), rect.height - d.offsetHeight - pad) + 'px';
      d.style.transform = `scale(${Math.min(Math.max(sizeScale, 0.6), 3)})`;
      d.style.opacity = '1';
      bubbleTimer = setTimeout(()=>{ d.remove(); bubbleTimer=null; }, bubbleLifetime);
    }

    function enqueueCommands(list){
      for(const c of list) commandQueue.push(c);
      if(!processingQueue) processQueue();
    }

    async function processQueue(){
      if(processingQueue) return;
      processingQueue = true;
      while(commandQueue.length){
        const cmd = commandQueue.shift();
        await executeStep(cmd);
        await new Promise(r => setTimeout(r, stepDelay));
      }
      processingQueue = false;
    }

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    function moveTo(targetX, targetY, duration = moveDuration){
      player.targetX = Math.max(24, Math.min(targetX, W-24));
      player.targetY = Math.max(24, Math.min(targetY, H-24));
      player.startX = player.x;
      player.startY = player.y;
      player.moveStart = performance.now();
      player.moveDuration = duration;
      if(!player.moving){
        player.moving = true;
        requestAnimationFrame(stepMovement);
      }
    }

    function stepMovement(now){
      if(!player.moving) return;
      const elapsed = now - player.moveStart;
      const t = Math.max(0, Math.min(1, elapsed / player.moveDuration));
      const eased = easeOutCubic(t);
      player.x = player.startX + (player.targetX - player.startX) * eased;
      player.y = player.startY + (player.targetY - player.startY) * eased;
      draw();
      if(t < 1){
        requestAnimationFrame(stepMovement);
      } else {
        player.moving = false;
        player.targetX = null;
        player.targetY = null;
      }
    }

    async function executeStep(cmd){
      const c = cmd.trim().toLowerCase();
      if(['up','down','left','right','dig','here','move','go'].includes(c)){
        if(c === 'up') moveTo(player.x, player.y - baseStep);
        else if(c === 'down') moveTo(player.x, player.y + baseStep);
        else if(c === 'left') moveTo(player.x - baseStep, player.y);
        else if(c === 'right') moveTo(player.x + baseStep, player.y);
        else if(c === 'here') showBubble('here', player.x, player.y - 36, 1.1);
        else if(c === 'dig'){ await waitForMovement(); performDig(); }
        else moveShorthand(c);
      } else {
        showBubble('unknown', player.x, player.y - 36, 1);
      }
    }

    function moveShorthand(text){
      const parts = text.split(/\s+/);
      const dx = (parts.includes('left') ? -1 : 0) + (parts.includes('right') ? 1 : 0);
      const dy = (parts.includes('up') ? -1 : 0) + (parts.includes('down') ? 1 : 0);
      if(dx !== 0 || dy !== 0){
        const stepX = dx * baseStep;
        const stepY = dy * baseStep;
        moveTo(player.x + stepX, player.y + stepY);
      }
    }

    function waitForMovement(){
      return new Promise(res=>{
        if(!player.moving) return res();
        const check = () => { if(!player.moving) return res(); requestAnimationFrame(check); };
        requestAnimationFrame(check);
      });
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function performDig(){
      let closestIdx = -1, closestDist = Infinity;
      for(let i=0;i<fountains.length;i++){
        const f = fountains[i];
        const d = distance(player.x,player.y,f.x,f.y);
        if(d < closestDist){ closestDist = d; closestIdx = i; }
      }
      const maxPossible = Math.hypot(W, H);
      if(closestDist <= detectOnTop){
        fountains[closestIdx].visible = true;
        showBubble('üéâ well done!', player.x, player.y - 64, 1.3);
        draw();
      } else if(closestDist <= detectNear){
        const t = clamp((closestDist - detectOnTop) / Math.max(1, (detectNear - detectOnTop)), 0, 1);
        const wetScale = 1.0 + (1 - t) * 1.6;
        showBubble('üíß wet', player.x, player.y - 48, wetScale);
      } else {
        const t = clamp((closestDist - detectNear) / Math.max(1, (maxPossible - detectNear)), 0, 1);
        const dryScale = 1.0 + t * 1.4;
        showBubble('üåµ dry', player.x, player.y - 48, dryScale);
      }
    }

    window.addEventListener('resize', ()=>{
      setCanvasSize();
      draw();
    });

    canvas.addEventListener('click', (ev)=>{
      const rect = canvas.getBoundingClientRect();
      const cx = (ev.clientX - rect.left) * (W / rect.width);
      const cy = (ev.clientY - rect.top) * (H / rect.height);
      moveTo(cx, cy, 260);
      enqueueCommands(['dig']);
    });

    window.addEventListener('keydown', (ev) => {
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      if(tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement && document.activeElement.isContentEditable) return;

      let handled = false;
      switch(ev.code){
        case 'ArrowUp':
          enqueueCommands(['up']);
          handled = true;
          break;
        case 'ArrowDown':
          enqueueCommands(['down']);
          handled = true;
          break;
        case 'ArrowLeft':
          enqueueCommands(['left']);
          handled = true;
          break;
        case 'ArrowRight':
          enqueueCommands(['right']);
          handled = true;
          break;
        case 'Space':
        case 'Spacebar':
          enqueueCommands(['dig']);
          handled = true;
          break;
        default:
          break;
      }
      if(handled){
        ev.preventDefault();
      }
    });

    setCanvasSize();
    placeFountains();
    resetGame();
  </script>
</body>
</html>